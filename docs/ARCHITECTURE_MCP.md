# Lumina 扩展架构决策:插件化 vs MCP

本文档记录了关于 Lumina 从"单体应用"向"微内核操作系统"转型的架构讨论与决策。核心议题围绕**传统插件化 (Plugins)** 与 **模型上下文协议 (MCP)** 的技术选型展开。

---

## 1. 核心比喻:焊接零件 vs USB 接口

为了理解两者的本质区别,我们使用以下核心类比:

- **传统插件化 (Hard-wired Plugins)**:

  - **比喻**:给一台机器内部**焊接一个新的零件**。
  - **特征**:你需要打开机器外壳,了解它的电路图(源代码),必须按照特定的电压和接口形状(特定的编程语言和框架规范)来定制零件。
  - **代价**:如果零件短路,整台机器都会烧毁。而且这个零件只能给这一种型号的机器用。

- **MCP (Model Context Protocol)**:
  - **比喻**:给机器安装一个 **USB 接口**。
  - **特征**:你不需要知道机器内部结构。只要你的设备符合 USB 协议(MCP 标准),插上去就能用。
  - **优势**:同一个 USB 鼠标(MCP 服务),既能插在电脑上(Lumina),也能插在平板上(Claude/Cursor)。

---

## 2. 技术深度对比

| 维度         | 传统插件化 (Dynamic Import)                            | MCP (Model Context Protocol)                                    |
| :----------- | :----------------------------------------------------- | :-------------------------------------------------------------- |
| **物理形态** | **同进程代码片段**                                     | **独立进程/服务**                                               |
| **耦合度**   | **高耦合**。插件代码必须依赖主程序的 SDK 和环境。      | **零耦合**。通过 JSON-RPC 协议通信,互不需要了解对方代码。      |
| **语言限制** | **强绑定**。Lumina 是 Python,插件也必须是 Python。    | **无限制**。可以用 Node/Go/Rust 写工具,Lumina 照样能调。       |
| **稳定性**   | **低**。插件崩溃会导致主进程崩溃(GIL 锁、内存泄漏)。 | **高**。插件运行在沙箱进程中,崩溃不影响主程序。                |
| **生态兼容** | 只能服务于 Lumina 自己的生态。                         | **工业标准**。同一套代码可兼容 Claude, Cursor, Zed 等顶级工具。 |
| **依赖管理** | 极易冲突。插件需要的库可能覆盖主程序版本。             | 独立环境。每个 MCP 维护自己的 `requirements.txt`,互不干扰。    |

---

## 3. 为什么 MCP 更有"未来感"?

1.  **标准化接口**:它不仅仅是"调用函数",它规范了**资源 (Resources)**、**提示词 (Prompts)** 和 **工具 (Tools)** 三大要素。这让 AI 能够更全面地感知外部世界。
2.  **社区即战力**:
    - **插件化**:我们需要等待开发者专门为 Lumina 编写插件。
    - **MCP**:我们可以直接使用 GitHub 上成千上万个现成的 MCP Server(如 Google Drive, PostgreSQL, Bilibili API)。无需移植,拿来即用。
3.  **对小白友好**:
    - 用户不需要理解复杂的配置面板。
    - 选择一个 MCP 就像选一个"技能包",AI 就会自动获得对应的 Prompt 预设和工具能力。

---

## 4. Lumina 最终架构建议:混合动力 (Hybrid Power)

考虑到 Lumina 作为 **"实时语音伴侣"** 的特殊性,我们不建议全盘采用 MCP,而是根据场景分层处理:

### **第一层:内核组件 (Internal Components)**

- **适用场景**:**高频、低延迟、大数据流**。
  - ASR (语音识别)
  - TTS (语音合成)
  - Live2D 驱动
  - VAD (音频活动检测)
- **策略**:保留目前的内部模块化或传统的事件驱动插件。因为 MCP 的协议开销(JSON 序列化/反序列化)可能会带来几十毫秒的延迟,影响对话的"打断感"。

### **第二层:外部技能 (External Skills - MCP)**

- **适用场景**:**逻辑处理、信息获取、低频操作**。
  - 联网搜索 (Internet Search)
  - 长时记忆检索 (Long-term Memory)
  - 智能家居控制 (IoT)
  - 文件系统操作 (File System)
  - 游戏数据交互 (Minecraft/Galgame)
- **策略**:全量拥抱 MCP。将这些功能从臃肿的 `main.py` 中剥离,变成独立运行的小卫星。

---

### **总结:从"瑞士军刀"到"智能插座"**

目前的 Lumina 是一把沉重的瑞士军刀,集成了太多用户可能不需要的功能。
未来的 Lumina Core 将是一个精简的 **"智能插座"**,它拥有最快的大脑和嘴巴(内核),并留出了无数个 USB 接口(MCP),让用户可以自由地喊着按照需求组装出属于自己的 AI 伴侣。

---

## 5. 最终落地蓝图:亦核亦插 (Dual-Track Architecture)

为了兼顾"小白开箱即用"与"高手无限改装",我们确定了 Lumina 的**最小生机内核 (Minimum Vital Kernel)** 和 **双轨扩展系统**。

### **A. 最小生机内核 (Default Bundle)**

这是一个"刷机包",包含最基础的、免费的、人人都能跑起来的功能。用户解压即玩,无需配置 Key。

1.  **灵魂系统 (Soul System)**:PAD、大五人格、关系演化(这是 Lumina 的心脏)。
2.  **核心记忆 (Memory/Soul)**:短时记忆流 + 基础向量库。
3.  **Chat (LLM)**:默认接入免费/本地 LLM 接口,或提供一个基础的 API 填空。
4.  **听觉 (Ear)**:内置 **SenseVoice (Local)** 插件。因为它极小、极快、且支持情感识别,是完美的默认选择。
5.  **嗓音 (Voice)**:内置 **EdgeTTS (Online)** 插件。因为它免费、无需显卡、音质尚可。

### **B. 双轨扩展机制**

| 扩展类型     | **核心驱动 (Drivers)**                                                           | **技能应用 (Apps / MCP)**                                                |
| :----------- | :------------------------------------------------------------------------------- | :----------------------------------------------------------------------- |
| **技术实现** | **进程内 Python 插件 (In-Process)**                                              | **独立进程 MCP (Inter-Process)**                                         |
| **安装方式** | 把文件放入 `plugins/drivers/`                                                    | 在设置页面填写 MCP Server URL                                            |
| **针对功能** | 替换**听觉/嗓音/形象**等机能部件。                                               | 增加**搜索/家居/游戏/笔记**等外部能力。                                  |
| **典型案例** | 用户嫌 EdgeTTS 没感情,下载 `GPT-SoVITS` 驱动包放入 `plugins/tts/`,重启即生效。 | 用户想让 AI 帮他定闹钟,安装 `Clock MCP`,AI 自动获得 `set_alarm` 工具。 |
| **性能损耗** | **0ms (零延迟)**                                                                 | **~50ms (协议通讯)**                                                     |

这套架构将彻底解决开发与体验的矛盾:主程序只维护"内核"和"扩展接口",所有的复杂度都下放给具体的插件。
